component_factory_header(file_name, guard, manifest, date, factory_decls) ::= <<
// <manifest>
// @date: <date>

#ifndef <guard>
#define <guard>

<includes()>

<delcares()>

<factory_decls:{x|<x>}; separator="\n\n">

#endif // <guard>

/// <file_name> ends here

>>

includes() ::= <<
#include \<memory\>
#include "icomponent_factory.h"
>>

delcares() ::= <<
class TiXmlElement;

namespace Json
{
    class Value;                    
}
>>

smart_ptr(class) ::= "std::auto_ptr\<<class>>"

component_factory_cpp(file_name, date, component_headers, component_factory_defines) ::= <<
// Automatically generated by happy world editor, DO NOT edit by hand.
// @date: <date>

#include "define.h"
#include "tinyxml.h"
#include "json/json.h"
#include "factory_exception.h"
#include "component_factory.h"
<component_headers:{x|#include "<x>"}; separator="\n">

<component_factory_defines:{x|<x>}; separator="\n\n">

/// <file_name> ends here

>>

component_factory_decl(factory_name, interface_name) ::= <<
class HW_BASE_API <factory_name> : public IComponentFactory
{
protected:
    virtual <smart_ptr(interface_name)> DoCreateFromXML(const TiXmlElement* data);

    virtual <smart_ptr(interface_name)> DoCreateFromJSON(const Json::Value& data);
};
>>

component_factory_define(class_name, factory_name, raw_name, find_component_node, build_attributes) ::= <<
<smart_ptr("IComponent")> <factory_name>::DoCreateFromXML(const TiXmlElement* data)
{
    const TiXmlElement *component_node = NULL;

    <find_component_node>

    if (component_node != NULL) {
        <smart_ptr(class_name)> p(GCC_NEW <class_name>);
        
        <build_attributes:{x|<x>}; separator="\n\n">

        return <smart_ptr("IComponent")>(p.release());
    }
    else throw ComponentNodeNotFound("<class_name>", __FILE__, __LINE__);
}

<smart_ptr("IComponent")> <factory_name>::DoCreateFromJSON(const Json::Value& data)
{
    const Json::Value& jv = data["<raw_name>"];
    
    if (!jv.isNull()) {
        <smart_ptr(class_name)> p(GCC_NEW <class_name>);

        if (p->FromJSONValue(jv)) {
            return <smart_ptr("IComponent")>(p.release());
        }
        else throw FromJSONValueFailed("<class_name>", jv.toStyledString().c_str(), __FILE__, __LINE__);
    }
    else throw JsonComponentNodeNotFound("<class_name>", data.toStyledString().c_str(), __FILE__, __LINE__);
}
>>

find_component_node(go_tag, raw_name, class_name) ::= <<
for (const TiXmlElement *node = data->FirstChildElement("<go_tag>");
     node; node = node->NextSiblingElement())
{
    const char* attribute_name = node->Attribute("name");
    if (attribute_name != NULL) {
        if (strcmp(attribute_name, "<raw_name>") == 0) {
            component_node = node;
            break;
        }
    }
    else throw ComponentNameNotFound("<class_name>", "<raw_name>",  __FILE__, __LINE__);
}
>>

build_atom_attribute(component_name, variable_name, attr_name, set_block) ::= <<
const TiXmlElement *ele_<variable_name> = component_node->FirstChildElement("<attr_name>");
if (ele_<variable_name>) {
    const char *text = ele_<variable_name>->GetText();
    if (text) {
        <set_block>
    }
    else throw AttributeValueNotFound("<component_name>", "<variable_name>", "<attr_name>", __FILE__, __LINE__);
}
else throw AttributeNotFound("<component_name>", "<variable_name>", "<attr_name>", __FILE__, __LINE__);
>>

build_array_attribute(component_name, variable_name, attr_name, set_block) ::= <<
const TiXmlElement *ele_<variable_name> = component_node->FirstChildElement("<attr_name>");
if (ele_<variable_name>) {
    <set_block>
}
else throw AttributeNotFound("<component_name>", "<variable_name>", "<attr_name>", __FILE__, __LINE__);
>>

set_int_array_value(attr, setter) ::= <<
std::vector\<int\> val_vec;

for (const TiXmlElement *item_node = ele_<attr>->FirstChildElement("item");
     item_node; item_node = item_node->NextSiblingElement())
{
    const char *text = item_node->GetText();
    val_vec.push_back(atoi(text));
}

p-><setter>(val_vec);
>>

set_string_array_value(attr, setter) ::= <<
std::vector\<std::string\> val_vec;

for (const TiXmlElement *item_node = ele_<attr>->FirstChildElement("item");
     item_node; item_node = item_node->NextSiblingElement())
{
    const char *text = item_node->GetText();
    val_vec.push_back(text);
}

p-><setter>(val_vec);
>>

set_enum_array_value(attr, setter, enum_int_val) ::= <<
std::vector\<int\> val_vec;

for (const TiXmlElement *item_node = ele_<attr>->FirstChildElement("item");
     item_node; item_node = item_node->NextSiblingElement())
{
    int tmp = -1;
    item_node->QueryIntAttribute("<enum_int_val>", &tmp);
    if (tmp != -1) {
       val_vec.push_back(tmp);   
    }
    else throw EnumAttributeValueNotFound("<attr>", __FILE__, __LINE__);
}

p-><setter>(val_vec);
>>

set_bool_array_value(attr, setter) ::= <<
std::vector\<bool\> val_vec;

for (const TiXmlElement *item_node = ele_<attr>->FirstChildElement("item");
     item_node; item_node = item_node->NextSiblingElement())
{
    const char *text = item_node->GetText();
    if (strcmp("true", text) == 0) {
        val_vec.push_back(true);
    } else if (strcmp("false", text)) {
        val_vec.push_back(false);
    } else throw BoolValueError("<attr>", text, __FILE__, __LINE__);
}

p-><setter>(val_vec);
>>

set_int_value(attr, setter) ::= <<
int <attr> = atoi(text);
p-><setter>(<attr>);
>>

set_string_value(attr, setter) ::= <<
p-><setter>(text);
>>

set_enum_value(attr, setter, enum_int_val) ::= <<
int <attr> = -1;
ele_<attr>->QueryIntAttribute("<enum_int_val>", &<attr>);
if (<attr> != -1) {
   p-><setter>(<attr>);
}
else throw EnumAttributeValueNotFound("<attr>", __FILE__, __LINE__);
>>

set_bool_value(attr, setter) ::= <<
if (strcmp("true", text) == 0) {
    p-><setter>(true);
} else if (strcmp("false", text) == 0) {
    p-><setter>(false);
}
else throw BoolValueError("<attr>", text, __FILE__, __LINE__);
>>

set_unknown_value(attr, setter, type) ::= <<
throw UnknownAttributeValueType("<attr>", "<type>", __FILE__, __LINE__);
>>
