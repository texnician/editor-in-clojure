component_factory_header(file_name, guard, manifest, date, factory_decls) ::= <<
// <manifest>
// @date: <date>

#ifndef <guard>
#define <guard>

<includes()>

<delcares()>

<factory_decls:{x|<x>}; separator="\n\n">

#endif // <guard>

/// <file_name> ends here

>>

includes() ::= <<
#include \<memory\>
#include "icomponent_factory.h"
>>

delcares() ::= <<
class TiXmlElement;

namespace Json
{
    class Value;                    
}

class HWDBRecordSet;

class HWSQLCmd;
>>

smart_ptr(class) ::= "std::auto_ptr\<<class>>"

component_factory_cpp(file_name, date, component_headers, component_factory_defines) ::= <<
// Automatically generated by happy world editor, DO NOT edit by hand.
// @date: <date>

#include "define.h"
#include "tinyxml.h"
#include "json/json.h"
#include "factory_exception.h"
#include "component_factory.h"
<component_headers:{x|#include "<x>"}; separator="\n">

<component_factory_defines:{x|<x>}; separator="\n\n">

/// <file_name> ends here

>>

component_factory_decl(factory_name, interface_name) ::= <<
class HW_BASE_API <factory_name> : public IComponentFactory
{
protected:
    virtual <smart_ptr(interface_name)> DoCreateFromXML(const TiXmlElement* data);

    virtual <smart_ptr(interface_name)> DoCreateFromJSON(const Json::Value& data);

    virtual Json::Value DoCreateJSONFromRecordSet(const HWDBRecordSet& data, const HWSQLCmd& cmd);
};
>>

component_factory_define(class_name, factory_name, raw_name, find_component_node, build_attributes, attributes_from_record_set) ::= <<
<smart_ptr("IComponent")> <factory_name>::DoCreateFromXML(const TiXmlElement* data)
{
    const TiXmlElement *component_node = NULL;

    <find_component_node>

    if (component_node != NULL) {
        <smart_ptr(class_name)> p(GCC_NEW <class_name>);
        
        <build_attributes:{x|<x>}; separator="\n\n">

        return <smart_ptr("IComponent")>(p.release());
    }
    else throw ComponentNodeNotFound("<class_name>", __FILE__, __LINE__);
}

<smart_ptr("IComponent")> <factory_name>::DoCreateFromJSON(const Json::Value& data)
{
    const Json::Value& jv = data["<raw_name>"];
    
    if (!jv.isNull()) {
        <smart_ptr(class_name)> p(GCC_NEW <class_name>);

        if (p->FromJSONValue(jv)) {
            return <smart_ptr("IComponent")>(p.release());
        }
        else throw FromJSONValueFailed("<class_name>", jv.toStyledString().c_str(), __FILE__, __LINE__);
    }
    else throw JsonComponentNodeNotFound("<class_name>", data.toStyledString().c_str(), __FILE__, __LINE__);
}

Json::Value <factory_name>::DoCreateJSONFromRecordSet(const HWDBRecordSet& rs, const HWSQLCmd& cmd)
{
    Json::Value jv;

    IHWDBCursorPtr root_cursor_ptr = rs.GetCursor();

    <attributes_from_record_set:{x|<x>}; separator="\n\n">
    
    return jv;
}
>>

find_component_node(go_tag, raw_name, class_name) ::= <<
for (const TiXmlElement *node = data->FirstChildElement("<go_tag>");
     node; node = node->NextSiblingElement())
{
    const char* attribute_name = node->Attribute("name");
    if (attribute_name != NULL) {
        if (strcmp(attribute_name, "<raw_name>") == 0) {
            component_node = node;
            break;
        }
    }
    else throw ComponentNameNotFound("<class_name>", "<raw_name>",  __FILE__, __LINE__);
}
>>

build_atom_attribute(component_name, variable_name, attr_name, set_block) ::= <<
const TiXmlElement *ele_<variable_name> = component_node->FirstChildElement("<attr_name>");
if (ele_<variable_name>) {
    const char *text = ele_<variable_name>->GetText();
    if (text) {
        <set_block>
    }
    else throw AttributeValueNotFound("<component_name>", "<variable_name>", "<attr_name>", __FILE__, __LINE__);
}
else throw AttributeNotFound("<component_name>", "<variable_name>", "<attr_name>", __FILE__, __LINE__);
>>

build_array_attribute(component_name, variable_name, attr_name, set_block) ::= <<
const TiXmlElement *ele_<variable_name> = component_node->FirstChildElement("<attr_name>");
if (ele_<variable_name>) {
    <set_block>
}
else throw AttributeNotFound("<component_name>", "<variable_name>", "<attr_name>", __FILE__, __LINE__);
>>

set_int_array_value(attr, setter, array_type, atoi) ::= <<
<array_type> val_vec;

for (const TiXmlElement *item_node = ele_<attr>->FirstChildElement("item");
     item_node; item_node = item_node->NextSiblingElement())
{
    const char *text = item_node->GetText();
    val_vec.push_back(<atoi>(text));
}

p-><setter>(val_vec);
>>

set_string_array_value(attr, setter) ::= <<
std::vector\<std::string\> val_vec;

for (const TiXmlElement *item_node = ele_<attr>->FirstChildElement("item");
     item_node; item_node = item_node->NextSiblingElement())
{
    const char *text = item_node->GetText();
    val_vec.push_back(text);
}

p-><setter>(val_vec);
>>

set_enum_array_value(attr, setter, enum_int_val) ::= <<
std::vector\<int\> val_vec;

for (const TiXmlElement *item_node = ele_<attr>->FirstChildElement("item");
     item_node; item_node = item_node->NextSiblingElement())
{
    int tmp = -1;
    item_node->QueryIntAttribute("<enum_int_val>", &tmp);
    if (tmp != -1) {
       val_vec.push_back(tmp);   
    }
    else throw EnumAttributeValueNotFound("<attr>", __FILE__, __LINE__);
}

p-><setter>(val_vec);
>>

set_bool_array_value(attr, setter) ::= <<
std::vector\<bool\> val_vec;

for (const TiXmlElement *item_node = ele_<attr>->FirstChildElement("item");
     item_node; item_node = item_node->NextSiblingElement())
{
    const char *text = item_node->GetText();
    if (strcmp("true", text) == 0) {
        val_vec.push_back(true);
    } else if (strcmp("false", text)) {
        val_vec.push_back(false);
    } else throw BoolValueError("<attr>", text, __FILE__, __LINE__);
}

p-><setter>(val_vec);
>>

set_int_value(attr, setter, int_type, atoi) ::= <<
<int_type> <attr> = <atoi>(text);
p-><setter>(<attr>);
>>

set_string_value(attr, setter) ::= <<
p-><setter>(text);
>>

set_enum_value(attr, setter, enum_int_val) ::= <<
int <attr> = -1;
ele_<attr>->QueryIntAttribute("<enum_int_val>", &<attr>);
if (<attr> != -1) {
   p-><setter>(<attr>);
}
else throw EnumAttributeValueNotFound("<attr>", __FILE__, __LINE__);
>>

set_bool_value(attr, setter) ::= <<
if (strcmp("true", text) == 0) {
    p-><setter>(true);
} else if (strcmp("false", text) == 0) {
    p-><setter>(false);
}
else throw BoolValueError("<attr>", text, __FILE__, __LINE__);
>>

set_unknown_value(attr, setter, type) ::= <<
throw UnknownAttributeValueType("<attr>", "<type>", __FILE__, __LINE__);
>>

atom_attribute_from_record_set(comp_name, attr_name, set_block) ::= <<
// Get "(<comp_name> :<attr_name>)"
<set_block>
>>

array_attribute_from_record_set(comp_name, attr_name, set_block) ::= <<
// Get "(<comp_name> :<attr_name>)"
{
    <set_block>
}
>>

set_int_from_record_set(int_type, variable_name, cursor_value_getter, field_name, comp_name, attr_name) ::= <<
<int_type> field_<variable_name> = 0;
<cursor_value_getter>(root_cursor_ptr, "<field_name>", &field_<variable_name>)
    ? jv["<attr_name>"] = field_<variable_name>
    : <throw_field_not_found(comp_name, attr_name, field_name, int_type)>
>>

set_string_from_record_set(variable_name, field_name, attr_name, comp_name) ::= <<
const char* field_<variable_name> = NULL;
GetStringFieldFromCursor(root_cursor_ptr, "<field_name>", &field_<varialbe_name>)
    ? jv["<attr_name>"] = field_<variable_name>
    : <throw_field_not_found(comp_name, attr_name, field_name, "string")>
>>

set_enum_from_record_set(variable_name, field_name, attr_name, comp_name) ::= <<
int field_<variable_name> = 0;
GetIntFieldFromCursor(root_cursor_ptr, "<field_name>", &field_<variable_name>)
    ? jv["<attr_name>"] = field_<variable_name>
    : <throw_field_not_found(comp_name, attr_name, field_name, "enum")>
>>

set_bool_from_record_set(variable_name, field_name, attr_name, comp_name) ::= <<
bool field_<variable_name> = false;
GetBoolFieldFromCursor(root_cursor_ptr, "<field_name>", &field_<variable_name>)
    ? jv["<attr_name>"] = field_<variable_name>
    : <throw_field_not_found(comp_name, attr_name, field_name, "bool")>
>>

set_int_array_from_record_set(attr_name, int_type, cursor_value_getter, field_name, comp_name) ::= <<
IHWDBCursorPtr sub_cursor_ptr = rs.GetSubRecordSet("<attr_name>").GetCursor();
if (sub_cursor_ptr) {
    std::vector\<<int_type>\> vec_val(sub_cursor_ptr->GetRecordCount());
    for (int i = 0; sub_cursor_ptr->GetRecord(); ++i) {
        if (!<cursor_value_getter>(sub_cursor_ptr, "<field_name>", &vec_val[i]))
            <throw_array_field_not_found(comp_name, attr_name, field_name, int_type)>
    }
    Json::Value& jv_items = jv["<attr_name>"];
    ArrayToJSONValue(vec_val, &jv_items);
}
>>

set_string_array_from_record_set(attr_name, field_name, comp_name) ::= <<
IHWDBCursorPtr sub_cursor_ptr = rs.GetSubRecordSet("<attr_name>").GetCursor();
if (sub_cursor_ptr) {
    std::vector\<std::string\> vec_val(sub_cursor_ptr->GetRecordCount());
    for (int i = 0; sub_cursor_ptr->GetRecord(); ++i) {
        const char* tmp = NULL;
        GetStringFieldFromCursor(sub_cursor_ptr, "<field_name>", &tmp)
            ? vec_val[i] = tmp
            : <throw_array_field_not_found(comp_name, attr_name, field_name, "string")>
    }
    Json::Value& jv_items = jv["<attr_name>"];
    ArrayToJSONValue(vec_val, &jv_items);
}
>>

set_enum_array_from_record_set(attr_name, field_name, comp_name) ::= <<
<set_int_array_from_record_set(attr_name, "int", "GetIntValueFromCursor", field_name, comp_name)>
>>

set_bool_array_from_record_set(attr_name, field_name, comp_name) ::= <<
<set_int_array_from_record_set(attr_name, "bool", "GetBoolValueFromCursor", field_name, comp_name)>
>>

throw_field_not_found(comp_name, attr_name, field_name, type) ::= <<
throw DBFieldNotFound("<comp_name>[\"<attr_name>\"]", "<field_name>", "<type>", cmd.DumpSQL(rs).c_str(), __FILE__, __LINE__);
>>

throw_array_field_not_found(comp_name, attr_name, field_name, type) ::= <<
throw DBFieldNotFound("<comp_name>[\"<attr_name>\"]", "<field_name>", "<type>", cmd.GetSubCmd("<attr_name>").DumpSQL(rs.GetSubRecordSet("<attr_name>")).c_str(), __FILE__, __LINE__);
>>


