component_factory_header(file_name, guard, manifest, date, factory_decls) ::= <<
// <manifest>
// @date: <date>

#ifndef <guard>
#define <guard>

<includes()>

<delcares()>

<factory_decls:{x|<x>}; separator="\n\n">

#endif // <guard>

/// <file_name> ends here

>>

includes() ::= <<
#include \<memory\>
#include "icomponent_factory.h"
>>

delcares() ::= <<
class TiXmlElement;

namespace Json
{
    class Value;                    
}

class HWDBRecordSet;

class HWSQLCmd;
>>

smart_ptr(class) ::= "std::auto_ptr\<<class>>"

component_factory_cpp(file_name, date, component_headers, component_factory_defines) ::= <<
# Automatically generated by happy world editor, DO NOT edit by hand.
# @date: <date>

import re
import py_component

NAME_TOKEN_PT = re.compile('([A-Z][a-z]+|[0-9][0-9]*)')

def _SplitName(name):
    return NAME_TOKEN_PT.findall(name)

def _FactoryName2ComponentName(factory_name):
    tokens = _SplitName(factory_name)
    return 'Py{0}Gen'.format(''.join(tokens[:-1]))

def _AttrName2RawName(name):
    return '-'.join(name.split('_'))

<component_factory_defines:{x|<x>}; separator="\n\n">

# <file_name> ends here

>>

component_factory_decl(factory_name, interface_name) ::= <<
class HW_BASE_API <factory_name> : public IComponentFactory
{
protected:
    virtual <smart_ptr(interface_name)> DoCreateFromXML(const TiXmlElement* data);

    virtual <smart_ptr(interface_name)> DoCreateFromJSON(const Json::Value& data);

    virtual Json::Value DoCreateJSONFromRecordSet(const HWDBRecordSet& data, const HWSQLCmd& cmd);
};
>>

component_factory_define(class_name, factory_name, raw_name, find_component_node, build_attributes, attributes_from_record_set) ::= <<
class Py<factory_name>(object):
    def CreateFromXML(self, xml_data):
        class_name = _FactoryName2ComponentName('<factory_name>')
        comp = eval('py_component.{0}()'.format(class_name))
        <build_attributes:{x|<x>}; separator="\n\n">
        return comp
>>

find_component_node(go_tag, raw_name, class_name) ::= <<
for (const TiXmlElement *node = data->FirstChildElement("<go_tag>");
     node; node = node->NextSiblingElement())
{
    const char* attribute_name = node->Attribute("name");
    if (attribute_name != NULL) {
        if (strcmp(attribute_name, "<raw_name>") == 0) {
            component_node = node;
            break;
        }
    }
    else throw ComponentNameNotFound("<class_name>", "<raw_name>",  __FILE__, __LINE__);
}
>>

build_atom_attribute(component_name, variable_name, attr_name, set_block) ::= <<
<set_block>
>>

build_array_attribute(component_name, variable_name, attr_name, set_block) ::= <<
<set_block>
>>

set_int_array_value(attr, setter, array_type, atoi) ::= <<
if 1:
    val_vec = []
    for v in xml_data[_AttrName2RawName('<attr>')]:
        val_vec.append(int(v))
    comp.<setter>(val_vec)
>>

set_string_array_value(attr, setter) ::= <<
if 1:
    comp.<setter>(xml_data[_AttrName2RawName('<attr>')])
>>

set_enum_array_value(attr, setter, enum_int_val) ::= <<
if 1:
    val_vec = []
    for v in xml_data[_AttrName2RawName('<attr>')]:
        val_vec.append(int(v))
    comp.<setter>(val_vec)
>>

set_bool_array_value(attr, setter) ::= <<
if 1:
    val_vec = []
    for v in xml_data[_AttrName2RawName('<attr>')]:
        tmp = True if v == 'true' else False
        val_vec.append(tmp)
    comp.<setter>(val_vec)
>>

set_int_value(attr, setter, int_type, atoi) ::= <<
if 1:
    comp.<setter>(int(xml_data[_AttrName2RawName('<attr>')]))
>>

set_string_value(attr, setter) ::= <<
if 1:
    comp.<setter>(xml_data[_AttrName2RawName('<attr>')])
>>

set_enum_value(attr, setter, enum_int_val) ::= <<
if 1:
    comp.<setter>(int(xml_data[_AttrName2RawName('<attr>')]));
>>

set_bool_value(attr, setter) ::= <<
if 1:
    tmp = True if xml_data[_AttrName2RawName('<attr>')] == 'true' else False
    comp.<setter>(tmp);
>>

set_unknown_value(attr, setter, type) ::= <<
assert False
>>

atom_attribute_from_record_set(comp_name, attr_name, set_block) ::= <<
// Get "(<comp_name> :<attr_name>)"
<set_block>
>>

array_attribute_from_record_set(comp_name, attr_name, set_block) ::= <<
// Get "(<comp_name> :<attr_name>)"
{
    <set_block>
}
>>

set_int_from_record_set(int_type, variable_name, cursor_value_getter, field_name, comp_name, attr_name) ::= <<
<int_type> field_<variable_name> = 0;
<cursor_value_getter>(root_cursor_ptr, "<field_name>", &field_<variable_name>)
    ? jv["<attr_name>"] = field_<variable_name>
    : <throw_field_not_found(comp_name, attr_name, field_name, int_type)>
>>

set_string_from_record_set(variable_name, field_name, attr_name, comp_name) ::= <<
const char* field_<variable_name> = NULL;
GetPODFieldFromCursor(root_cursor_ptr, "<field_name>", &field_<variable_name>)
    ? jv["<attr_name>"] = field_<variable_name>
    : <throw_field_not_found(comp_name, attr_name, field_name, "string")>
>>

set_enum_from_record_set(variable_name, field_name, attr_name, comp_name) ::= <<
int field_<variable_name> = 0;
GetPODFieldFromCursor(root_cursor_ptr, "<field_name>", &field_<variable_name>)
    ? jv["<attr_name>"] = field_<variable_name>
    : <throw_field_not_found(comp_name, attr_name, field_name, "enum")>
>>

set_bool_from_record_set(variable_name, field_name, attr_name, comp_name) ::= <<
bool field_<variable_name> = false;
GetPODFieldFromCursor(root_cursor_ptr, "<field_name>", &field_<variable_name>)
    ? jv["<attr_name>"] = field_<variable_name>
    : <throw_field_not_found(comp_name, attr_name, field_name, "bool")>
>>

set_int_array_from_record_set(attr_name, int_type, cursor_value_getter, field_name, comp_name) ::= <<
IHWDBCursorPtr sub_cursor_ptr = rs.GetSubRecordSet("<attr_name>").GetCursor();
if (sub_cursor_ptr) {
    <int_type> vec_val(sub_cursor_ptr->GetRecordCount());
    for (int i = 0; sub_cursor_ptr->GetRecord(); ++i) {
        if (!<cursor_value_getter>(sub_cursor_ptr, "<field_name>", &vec_val[i]))
            <throw_array_field_not_found(comp_name, attr_name, field_name, int_type)>
    }
    Json::Value& jv_items = jv["<attr_name>"];
    ArrayToJsonValue(vec_val, &jv_items);
}
>>

set_string_array_from_record_set(attr_name, field_name, comp_name) ::= <<
IHWDBCursorPtr sub_cursor_ptr = rs.GetSubRecordSet("<attr_name>").GetCursor();
if (sub_cursor_ptr) {
    std::vector\<std::string\> vec_val(sub_cursor_ptr->GetRecordCount());
    for (int i = 0; sub_cursor_ptr->GetRecord(); ++i) {
        const char* tmp = NULL;
        GetPODFieldFromCursor(sub_cursor_ptr, "<field_name>", &tmp)
            ? vec_val[i] = tmp
            : <throw_array_field_not_found(comp_name, attr_name, field_name, "string")>
    }
    Json::Value& jv_items = jv["<attr_name>"];
    ArrayToJsonValue(vec_val, &jv_items);
}
>>

set_enum_array_from_record_set(attr_name, field_name, comp_name) ::= <<
<set_int_array_from_record_set(attr_name, "std::vector<int>", "GetPODFieldFromCursor", field_name, comp_name)>
>>

set_bool_array_from_record_set(attr_name, field_name, comp_name) ::= <<
<set_int_array_from_record_set(attr_name, "std::vector<bool>", "GetPODFieldFromCursor", field_name, comp_name)>
>>

throw_field_not_found(comp_name, attr_name, field_name, type) ::= <<
throw DBFieldNotFound("<comp_name>[\"<attr_name>\"]", "<field_name>", "<type>", cmd.DumpSQL(rs).c_str(), __FILE__, __LINE__);
>>

throw_array_field_not_found(comp_name, attr_name, field_name, type) ::= <<
throw DBFieldNotFound("<comp_name>[\"<attr_name>\"]", "<field_name>", "<type>", cmd.GetSubCmd("<attr_name>").DumpSQL(rs.GetSubRecordSet("<attr_name>")).c_str(), __FILE__, __LINE__);
>>
